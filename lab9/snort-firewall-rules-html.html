<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snort and Firewall Rules</title>
    <link rel="stylesheet" href="../css/styles.css">
    <script src="../js/ui-controls.js"></script>
    <script src="../js/screenshot-handler.js"></script>
    <script src="../js/scripts.js"></script>
</head>
<body>
    <!-- Report header will be loaded here -->
    <div class="report-header" role="banner"></div>

    <!-- Control buttons will be loaded here -->
    <div class="controls-container" role="navigation"></div>

    <main role="main">
        <article>
            <section>
                <h2>Topology</h2>
                <div class="screenshot-container">
                    <div class="screenshot-upload"></div>
                </div>
                <p><em>Screenshot of the CyberOps Workstation VM Mininet. The network includes r1 which is the Router Firewall IDS and r4 which is the ISP router. There are three LANS connected to r1, one has DMZ servers, one has Internal servers and one has internal Users. An attacker and Web Servers, one hosting malware, is connected to the ISP router.</em></p>
            </section>

            <section>
                <h2>Objectives</h2>
                <p>Part 1: Preparing the Virtual Environment</p>
                <p>Part 2: Firewall and IDS Logs</p>
                <p>Part 3: Terminate and Clear Mininet Process</p>
            </section>

            <section>
                <h2>Background / Scenario</h2>
                <p>In a secure production network, network alerts are generated by various types of devices such as security appliances, firewalls, IPS devices, routers, switches, servers, and more. The problem is that not all alerts are created equally. For example, alerts generated by a server and alerts generated by a firewall will be different and vary in content and format.</p>
                <p>In this lab, to get familiar with firewall rules and IDS signatures.</p>
            </section>

            <section>
                <h2>Required Resources</h2>
                <ul>
                    <li>CyberOps Workstation virtual machine</li>
                    <li>Internet connection</li>
                </ul>
                <p><strong>Note</strong>: In this lab, the CyberOps Workstation VM is a container for holding the Mininet environment shown in the Topology. If a memory error is received in an attempt to run any command, quit out of the step, go to the VM settings, and increase the memory. The default is 1 GB; try 2GB.</p>
            </section>

            <section>
                <h2>Instructions</h2>

                <h3>Part 1: Preparing the Virtual Environment</h3>
                <p>a. Launch <strong>Oracle VirtualBox</strong></p>
                
                <p>b. Launch the <strong>CyberOps Workstation VM</strong>, open a terminal and configure its network by executing the <strong>configure_as_dhcp.sh</strong> script.</p>
                <p>Because the script requires super-user privileges, provide the password for the user <strong>analyst</strong>.</p>
                
                <pre>[analyst@secOps ~]$ <strong>sudo ./lab.support.files/scripts/configure_as_dhcp.sh</strong>
[sudo] password for analyst:
[analyst@secOps ~]$</pre>

                <div class="screenshot-container"></div>

                <p>c. Use the <strong>ifconfig</strong> command to verify <strong>CyberOps Workstation VM</strong> now has an IP address on your local network. You can also test connectivity to a public webserver by pinging www.cisco.com. Use <strong>Ctrl+C</strong> to stop the pings.</p>
                
                <pre>[analyst@secOps ~]$ <strong>ping www.cisco.com</strong>
PING e2867.dsca.akamaiedge.net (23.204.15.199) 56(84) bytes of data.
64 bytes from a23-204-15-199.deploy.static.akamaitechnologies.com (23.204.15.199): icmp_seq=1 ttl=54 time=28.4 ms
64 bytes from a23-204-15-199.deploy.static.akamaitechnologies.com (23.204.15.199): icmp_seq=2 ttl=54 time=35.5 ms
^C
--- e2867.dsca.akamaiedge.net ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 28.446/32.020/35.595/3.578 ms</pre>

                <div class="screenshot-container"></div>

                <h3>Part 2: Firewall and IDS Logs</h3>
                <p>Firewalls and Intrusion Detection Systems (IDS) are often deployed to partially automate the traffic monitoring task. Both firewalls and IDSs match incoming traffic against administrative rules. Firewalls usually compare the packet header against a rule set while IDSs often use the packet payload for rule set comparison. Because firewalls and IDSs apply the pre-defined rules to different portions of the IP packet, IDS and firewall rules have different structures.</p>
                
                <p>While there is a difference in rule structure, some similarities between the components of the rules remain. For example, both firewall and IDS rules contain matching components and action components. Actions are taken after a match is found.</p>
                
                <ul>
                    <li><strong>Matching component</strong> - specifies the packet elements of interest, such as: packet source; the packet destination; transport layer protocols and ports; and data included in the packet payload.</li>
                    <li><strong>Action component</strong> - specifies what should be done with that packet that matches a component, such as: accept and forward the packet; drop the packet; or send the packet to a secondary rule set for further inspection.</li>
                </ul>
                
                <p>A common firewall design is to drop packets by default while manually specifying what traffic should be allowed. Known as dropping-by-default, this design has the advantage protecting the network from unknown protocols and attacks. As part of this design, it is common to log the events of dropped packets since these are packets that were not explicitly allowed and therefore, infringe on the organization's policies. Such events should be recorded for future analysis.</p>

                <h4>Step 1: Real-Time IDS Log Monitoring</h4>
                <p>a. From the <strong>CyberOps Workstation VM</strong>, run the script to start <strong>mininet</strong>.</p>
                
                <pre>[analyst@secOps ~]$ <strong>sudo ./lab.support.files/scripts/cyberops_extended_topo_no_fw.py</strong>
[sudo] password for analyst:
*** Adding controller
*** Add switches
*** Add hosts
*** Add links
*** Starting network
*** Configuring hosts
R1 R4 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11
*** Starting controllers
*** Starting switches
*** Add routes
*** Post configure switches and hosts
*** Starting CLI:
mininet></pre>

                <div class="screenshot-container"></div>

                <p>The <strong>mininet</strong> prompt should be displayed, indicating <strong>mininet</strong> is ready for commands.</p>
                
                <p>b. From the <strong>mininet</strong> prompt, open a shell on <strong>R1</strong> using the command below:</p>
                
                <pre>mininet> <strong>xterm R1</strong>
mininet></pre>

                <div class="screenshot-container"></div>

                <p class="question">The <strong>R1</strong> shell opens in a terminal window with black text and white background. What user is logged into that shell? What is the indicator of this?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p>c. From <strong>R1</strong>'s shell, start the Linux-based IDS, Snort.</p>
                
                <pre>[root@secOps analyst]# <strong>./lab.support.files/scripts/start_snort.sh</strong>
Running in IDS mode
--== Initializing Snort ==--
Initializing Output Plugins!
Initializing Preprocessors!
Initializing Plug-ins!
Parsing Rules file "/etc/snort/snort.conf"
<output omitted></pre>

                <div class="screenshot-container"></div>

                <p><strong>Note:</strong> You will not see a prompt as Snort is now running in this window. If for any reason, Snort stops running and the <strong>[root@secOps analysts]#</strong> prompt is displayed, rerun the script to launch Snort. Snort must be running to capture alerts later in the lab.</p>
                
                <p>d. From the <strong>CyberOps Workstation VM</strong> <strong>mininet</strong> prompt, open shells for hosts <strong>H5</strong> and <strong>H10</strong>.</p>
                
                <pre>mininet> <strong>xterm H5</strong>
mininet> <strong>xterm H10</strong>
mininet></pre>

                <div class="screenshot-container"></div>

                <p>e. <strong>H10</strong> will simulate a server on the Internet that is hosting malware. On <strong>H10</strong>, run the <strong>mal_server_start.sh</strong> script to start the server.</p>
                
                <pre>[root@secOps analyst]# <strong>./lab.support.files/scripts/mal_server_start.sh</strong>
[root@secOps analyst]#</pre>

                <div class="screenshot-container"></div>

                <p>f. On <strong>H10</strong>, use <strong>netstat</strong> with the <strong>-tunpa</strong> options to verify that the web server is running. When used as shown below, <strong>netstat</strong> lists all ports currently assigned to services:</p>
                
                <pre>[root@secOps analyst]# <strong>netstat -tunpa</strong>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
<span class="mark">tcp</span>   0      0 0.0.0.0:<span class="mark">6666</span>            0.0.0.0:*               <span class="mark">LISTEN</span>      1839/<span class="mark">nginx</span>: master
[root@secOps analyst]#</pre>

                <div class="screenshot-container"></div>

                <p>As seen by the output above, the lightweight webserver <strong>nginx</strong> is running and listening to connections on port TCP 6666.</p>
                
                <p>g. In the <strong>R1</strong> terminal window, an instance of Snort is running. To enter more commands on <strong>R1</strong>, open another <strong>R1</strong> terminal by entering the <strong>xterm R1</strong> again in the <strong>CyberOps Workstation VM</strong> terminal window. You may also want to arrange the terminal windows so that you can see and interact with each device.</p>
                
                <div class="screenshot-container"></div>

                <p>h. In the new <strong>R1</strong> terminal tab, run the <strong>tail</strong> command with the <strong>-f</strong> option to monitor the <strong>/var/log/snort/alert</strong> file in real-time. This file is where snort is configured to record alerts.</p>
                
                <pre>[root@sec0ps analyst]# <strong>tail -f /var/log/snort/alert</strong></pre>

                <div class="screenshot-container"></div>

                <p>Because no alerts were yet recorded, the log should be empty. However, if you have run this lab before, old alert entries may be shown. In either case, you will not receive a prompt after typing this command. This window will display alerts as they happen.</p>
                
                <p>i. From <strong>H5</strong>, use the <strong>wget</strong> command to download a file named <strong>W32.Nimda.Amm.exe</strong>. Designed to download content via HTTP, <strong>wget</strong> is a great tool for downloading files from web servers directly from the command line.</p>
                
                <pre>[root@secOps analyst]# <strong>wget 209.165.202.133:6666/W32.Nimda.Amm.exe</strong>
--2017-04-28 17:00:04-- http://209.165.202.133:6666/W32.Nimda.Amm.exe
Connecting to 209.165.202.133:6666... connected.
HTTP request sent, awaiting response... 200 OK
Length: 345088 (337K) [application/octet-stream]
Saving to: 'W32.Nimda.Amm.exe'

W32.Nimda.Amm.exe   100%[===================>]  337.00K  --.-KB/s    in 0.02s  

2017-04-28 17:00:04 (16.4 MB/s) - 'W32.Nimda.Amm.exe' saved [345088/345088]

[root@secOps analyst]#</pre>

                <div class="screenshot-container"></div>

                <p class="question">What port is used when communicating with the malware web server? What is the indicator?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p class="question">Was the file completely downloaded?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p class="question">Did the IDS generate any alerts related to the file download?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p>j. As the malicious file was transiting <strong>R1</strong>, the IDS, Snort, was able to inspect its payload. The payload matched at least one of the signatures configured in Snort and triggered an alert on the second <strong>R1</strong> terminal window (the tab where <strong>tail -f</strong> is running). The alert entry is show below. Your timestamp will be different:</p>
                
                <pre>04/28-17:00:04.092153  [**] [1:1000003:0] Malicious Server Hit! [**] [Priority: 0] {TCP} 209.165.200.235:34484 -> 209.165.202.133:6666</pre>

                <div class="screenshot-container"></div>

                <p class="question">Based on the alert shown above, what was the source and destination IPv4 addresses used in the transaction?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p class="question">Based on the alert shown above, what was the source and destination ports used in the transaction?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p class="question">Based on the alert shown above, when did the download take place?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p class="question">Based on the alert shown above, what was the message recorded by the IDS signature?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p>On <strong>H5</strong>, use the <strong>tcpdump</strong> command to capture the event and download the malware file again so you can capture the transaction. Issue the following command below start the packet capture:</p>
                
                <pre>[root@secOps analyst]# <strong>tcpdump --i H5-eth0 --w nimda.download.pcap &</strong>
[1] 5633
[root@secOps analyst]# tcpdump: listening on H5-eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</pre>

                <div class="screenshot-container"></div>

                <p>The command above instructs tcpdump to capture packets on interface <strong>H5-eth0</strong> and save the capture to a file named <strong>nimda.download.pcap</strong>.</p>
                
                <p>The <strong>&</strong> symbol at the end tells the shell to execute <strong>tcpdump</strong> in the background. Without this symbol, <strong>tcpdump</strong> would make the terminal unusable while it was running. Notice the <strong>[1] 5633</strong>; it indicates one process was sent to background and its process ID (PID) is 5366. Your PID will most likely be different.</p>
                
                <p>k. Press <strong>ENTER</strong> a few times to regain control of the shell while <strong>tcpdump</strong> runs in background.</p>
                
                <div class="screenshot-container"></div>

                <p>l. Now that <strong>tcpdump</strong> is capturing packets, download the malware again. On <strong>H5</strong>, re-run the command or use the up arrow to recall it from the command history facility.</p>
                
                <pre>[root@secOps analyst]# <strong>wget 209.165.202.133:6666/W32.Nimda.Amm.exe</strong>
--2017-05-02 10:26:50-- http://209.165.202.133:6666/W32.Nimda.Amm.exe
Connecting to 209.165.202.133:6666... connected.
HTTP request sent, awaiting response... 200 OK
Length: 345088 (337K) [application/octet-stream]
Saving to: 'W32.Nimda.Amm.exe'

W32.Nimda.Amm.exe   100%[====================>]  337.00K  --.-KB/s    in 0.003s  

2017-05-02 10:26:50 (105 MB/s) - 'W32.Nimda.Amm.exe' saved [345088/345088]</pre>

                <div class="screenshot-container"></div>

                <p>m. Stop the capture by bringing <strong>tcpdump</strong> to foreground with the <strong>fg</strong> command. Because <strong>tcpdump</strong> was the only process sent to background, there is no need to specify the PID. Stop the <strong>tcpdump</strong> process with <strong>Ctrl+C</strong>. The <strong>tcpdump</strong> process stops and displays a summary of the capture. The number of packets may be different for your capture.</p>
                
                <pre>[root@secOps analyst]# <strong>fg</strong>
tcpdump -i h5-eth0 -w nimda.download.pcap
<span class="mark">^C</span>316 packets captured
316 packets received by filter
0 packets dropped by kernel
[root@secOps analyst]#</pre>

                <div class="screenshot-container"></div>

                <p>n. On <strong>H5</strong>, Use the <strong>ls</strong> command to verify the pcap file was in fact saved to disk and has size greater than zero:</p>
                
                <pre>[root@secOps analyst]# <strong>ls -l</strong>
total 1400
drwxr-xr-x 2 analyst analyst   4096 Sep 26  2014 Desktop
drwx------ 3 analyst analyst   4096 Jul 14 11:28 Downloads
drwxr-xr-x 8 analyst analyst   4096 Jul 25 16:27 lab.support.files
<span class="mark">-rw-r--r-- 1 root    root    371784 Aug 17 14:48 nimda.download.pcap</span>
drwxr-xr-x 2 analyst analyst   4096 Mar  3 15:56 second_drive
-rw-r--r-- 1 root    root    345088 Apr 14 15:17 W32.Nimda.Amm.exe
-rw-r--r-- 1 root    root    345088 Apr 14 15:17 W32.Nimda.Amm.exe.1
[root@secOps analyst]#</pre>

                <div class="screenshot-container"></div>

                <p><strong>Note</strong>: Your directory list may have a different mix of files, but you should still see the <strong>nimda.download.pcap</strong> file.</p>
                
                <p class="question">How can be this PCAP file be useful to the security analyst?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p><strong>Note</strong>: The analysis of the PCAP file will be performed in another lab.</p>

                <h4>Step 2: Tuning Firewall Rules Based on IDS Alerts</h4>
                <p>In Step 1, you started an internet-based malicious server. To keep other users from reaching that server, it is recommended to block it in the edge firewall.</p>
                
                <p>In this lab's topology, <strong>R1</strong> is not only running an IDS but also a very popular Linux-based firewall called <strong>iptables</strong>. In this step, you will block traffic to the malicious server identified in Step 1 by editing the firewall rules currently present in <strong>R1</strong>.</p>
                
                <p><strong>Note</strong>: While a comprehensive study of <strong>iptables</strong> is beyond the scope of this course, <strong>iptables</strong> basic logic and rule structure is fairly straight-forward.</p>
                
                <p>The firewall <strong>iptables</strong> uses the concepts of <em>chains</em> and <em>rules</em> to filter traffic.</p>
                
                <p>Traffic entering the firewall and destined to the firewall device itself is handled by the <strong>INPUT</strong> chain. Examples of this traffic are ping packets coming from any other device on any networks and sent to any one of the firewall's interfaces.</p>
                
                <p>Traffic originated in the firewall device itself and destined to somewhere else, is handled by the <strong>OUTPUT</strong> chain. Examples of this traffic are ping responses generated by the firewall device itself.</p>
                
                <p>Traffic originated somewhere else and passing through the firewall device is handled by the <strong>FORWARD</strong> chain. Examples of this traffic are packets being routed by the firewall.</p>
                
                <p>Each chain can have its own set of independent rules specifying how traffic is to be filtered for that chain. A chain can have practically any number of rules, including no rule at all.</p>
                
                <p>Rules are created to check specific characteristics of packets, allowing administrators to create very comprehensive filters. If a packet doesn't match a rule, the firewall moves on to the next rule and checks again. If a match is found, the firewall takes the action defined in the matching rule. If all rules in a chain have been checked and yet no match was found, the firewall takes the action specified in the chain's policy, usually allow the packet to flow through or deny it.</p>
                
                <p>o. In the <strong>CyberOps Workstation VM</strong>, start a third R1 terminal window.</p>
                
                <pre>mininet > <strong>xterm R1</strong></pre>

                <div class="screenshot-container"></div>

                <p>p. In the new <strong>R1</strong> terminal window, use the <strong>iptables</strong> command to list the chains and their rules currently in use:</p>
                
                <pre>[root@secOps ~]# <strong>iptables -L -v</strong>
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 6 packets, 504 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@secOps ~]#</pre>

                <div class="screenshot-container"></div>

                <p class="question">What chains are currently in use by <strong>R1</strong>?</p>
                <div class="text-answer" contenteditable="true"></div>

                <p>q. Connections to the malicious server generate packets that must transverse the <strong>iptables</strong> firewall on <strong>R1</strong>. Packets traversing the firewall are handled by the FORWARD rule and therefore, that is the chain that will receive the blocking rule. To keep user computers from connecting to the malicious server identified in Step 1, add the following rule to the FORWARD chain on <strong>R1</strong>:</p>
                
                <pre>[root@secOps ~]# <strong>iptables -I FORWARD -p tcp -d 209.165.202.133 --dport 6666 -j DROP</strong>
[root@secOps ~]#</pre>

                <div class="screenshot-container"></div>

                <p>Where:</p>
                <ul>
                    <li><strong>-I FORWARD</strong>: inserts a new rule in the FORWARD chain.</li>
                    <li><strong>-p tcp</strong>: specifies the TCP protocol.</li>
                    <li><strong>-d 209.165.202.133</strong>: specifies the packet's destination</li>
                    <li><strong>--dport 6666</strong>: specifies the destination port</li>
                    <li><strong>-j DROP</strong>: set the action to drop.</li>
                </ul>
                
                <p>a. Use the <strong>iptables</strong> command again to ensure the rule was added to the FORWARD chain. The CyberOps Workstation VM may take a few seconds to generate the output:</p>
                
                <pre>[root@secOps analyst]# <strong>iptables -L -v</strong>
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
<span class="mark">0     0 DROP       tcp  --  any    any     anywhere             209.165.202.133      tcp dpt:6666</span>

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@secOps analyst]#</pre>

                <div class="screenshot-container"></div>

                <p>b. On <strong>H5</strong>, try to download the file again:</p>
                
                <pre>[root@secOps analyst]# <strong>wget 209.165.202.133:6666/W32.Nimda.Amm.exe</strong>
--2017-05-01 14:42:37-- http://209.165.202.133:6666/W32.Nimda.Amm.exe
Connecting to 209.165.202.133:6666... failed: Connection timed out.
Retrying.

--2017-05-01 14:44:47-- (try: 2) http://209.165.202.133:6666/W32.Nimda.Amm.exe
Connecting to 209.165.202.133:6666... failed: Connection timed out.
Retrying.</pre>

                <div class="screenshot-container"></div>

                <p>Enter <strong>Ctrl+C</strong> to cancel the download, if necessary.</p>
                
                <p class="question">Was the download successful this time? Explain.</p>
                <div class="text-answer" contenteditable="true"></div>

                <p class="question">What would be a more aggressive but also valid approach when blocking the offending server?</p>
                <div class="text-answer" contenteditable="true"></div>

                <h3>Part 3: Terminate and Clear Mininet Process</h3>
                <p>c. Navigate to the terminal used to start Mininet. Terminate the Mininet by entering <strong>quit</strong> in the main CyberOps VM terminal window.</p>
                
                <div class="screenshot-container"></div>

                <p>d. After quitting Mininet, clean up the processes started by Mininet. Enter the password <strong>cyberops</strong> when prompted.</p>
                
                <pre>[analyst@secOps scripts]$ <strong>sudo mn --c</strong>
[sudo] password for analyst:</pre>

                <div class="screenshot-container"></div>
            </section>
        </article>
    </main>
</body>
</html>